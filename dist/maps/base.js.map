{"version":3,"sources":["app/js/app.js","app/js/controllers/fitch.controller.js","app/js/controllers/main.controller.js","app/js/controllers/menu.controller.js","app/js/controllers/truth-table.controller.js","app/js/services/fitch/fitch-stack.model.js","app/js/services/fitch/premise-tree.model.js","app/js/services/fitch/scope.model.js","app/js/services/formula.service.js","app/js/services/syntax.service.js","app/js/services/fitch/rules/bicondition.service.js","app/js/services/fitch/rules/conjunction.service.js","app/js/services/fitch/rules/disjunction.service.js","app/js/services/fitch/rules/implication.service.js","app/js/services/fitch/rules/negation.service.js","app/js/services/premise/premise.model.js","app/js/services/tables/table-generator.service.js","app/js/services/tables/table.model.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"base.js","sourcesContent":["'use strict';\r\n\r\nangular\r\n    .module('logicToolsApp', ['ui.router'])\r\n    .config(function ($stateProvider, $urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/');\r\n        $stateProvider\r\n            .state('main', {\r\n                url: '/',\r\n                templateUrl: 'templates/main.html',\r\n                controller: 'MainCtrl as main'\r\n            })\r\n            .state('truthTables', {\r\n                url: '/truth-tables',\r\n                templateUrl: 'templates/truth-table.html',\r\n                controller: 'TruthTableCtrl as table'\r\n            })\r\n            .state('fitchSystems', {\r\n                url: '/fitch',\r\n                templateUrl: 'templates/fitch.html',\r\n                controller: 'FitchCtrl as fitch'\r\n            });\r\n    })\r\n","'use strict';\r\n\r\nangular\r\n  .module('logicToolsApp')\r\n  .controller('FitchCtrl', function (\r\n      FitchStack,\r\n      Premise,\r\n      PremiseTree,\r\n      fitchBicondition,\r\n      fitchConjunction,\r\n      fitchDisjunction,\r\n      fitchImplication,\r\n      fitchNegation,\r\n      syntaxChecker\r\n    ) {\r\n\r\n      _init.call(this);\r\n\r\n      this.assume = function() {\r\n        var currentScope, labels, headPremise;\r\n\r\n        headPremise = Premise.new({\r\n          value: this.premise\r\n        });\r\n\r\n        if (!syntaxChecker.validate(headPremise)) {\r\n          return;\r\n        }\r\n\r\n        this.structure.openScope(headPremise);\r\n        currentScope = this.structure.getCurrentScope();\r\n        headPremise.scopeId = currentScope.id;\r\n        headPremise.scopeLayer = currentScope.layer;\r\n        this.premiseGraph.appendNode(headPremise);\r\n        this.premise = '';\r\n      };\r\n\r\n      this.refresh = function () {\r\n        _init.call(this);\r\n      }\r\n\r\n      this.closeDisjoinField = function () {\r\n        this.showDisjoinField = false;\r\n        this.valueToDisjoin = '';\r\n      }\r\n\r\n      this.disjoinPremise = function () {\r\n        var newPremises, currentScope, selected, disjointPremise;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (!selected.length || !this.valueToDisjoin) {\r\n            return;\r\n        }\r\n        newPremises = fitchDisjunction.introduction(this.valueToDisjoin, selected, currentScope);\r\n        this.showDisjoinField = false;\r\n        this.valueToDisjoin = '';\r\n        if (!newPremises) {\r\n            return;\r\n        }\r\n        _multipleEntialment.call(this, newPremises, selected);\r\n      };\r\n\r\n      /*Operations*/\r\n      this.andIntroduction = function () {\r\n        var selected, newPremises, secondPremise, currentScope;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length < 2) {\r\n          return;\r\n        }\r\n        newPremises = fitchConjunction.introduction(selected, currentScope);\r\n        if (!newPremises) {\r\n          return;\r\n        }\r\n        _multipleEntialment.call(this, newPremises, selected);\r\n      };\r\n      this.andElimination = function () {\r\n        var selected, newPremises, secondPremise, currentScope;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length !== 1) {\r\n          return;\r\n        }\r\n        newPremises = fitchConjunction.elimination(selected[0], currentScope);\r\n        if (!newPremises) {\r\n          return;\r\n        }\r\n        _multipleEntialment.call(this, newPremises, selected);\r\n      };\r\n      this.negationIntro = function() {\r\n        var selected, newPremise, secondPremise, currentScope;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length !== 2) {\r\n          return;\r\n        }\r\n        newPremise = fitchNegation.introduction(selected[0], selected[1], currentScope);\r\n        if (!newPremise) {\r\n          return;\r\n        }\r\n        _entail.call(this, newPremise, selected);\r\n      };\r\n      this.negationElim = function() {\r\n        var selected, newPremise, secondPremise, currentScope;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length > 1) {\r\n          return;\r\n        }\r\n        newPremise = fitchNegation.elimination(selected[0], currentScope);\r\n        if (!newPremise) {\r\n          return;\r\n        }\r\n        _entail.call(this, newPremise, selected);\r\n      };\r\n      this.implicationIntro = function() {\r\n        var lastScope, currentScope, newPremise;\r\n        lastScope = this.structure.closeScope();\r\n        currentScope = this.structure.getCurrentScope();\r\n        newPremise = fitchImplication.introduction(currentScope, lastScope);\r\n        _entail.call(this, newPremise, [lastScope.head, lastScope.last]);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n      };\r\n\r\n      this.implicationElim = function() {\r\n        var selected, newPremise, secondPremise, currentScope;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length !== 2) {\r\n          return;\r\n        }\r\n        newPremise = fitchImplication.elimination(selected[0], selected[1], currentScope);\r\n        if (!newPremise) {\r\n          return;\r\n        }\r\n        _entail.call(this, newPremise, selected);\r\n      };\r\n\r\n      this.orElimination = function () {\r\n        var selected, currentScope, newPremise, groupedPremises;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length < 3) {\r\n          return;\r\n        }\r\n        groupedPremises = _groupOrPremises(selected);\r\n        if (!groupedPremises) {\r\n          return;\r\n        }\r\n        newPremise = fitchDisjunction.elimination(groupedPremises, currentScope);\r\n        if (!newPremise) {\r\n          return;\r\n        }\r\n        _entail.call(this, newPremise, groupedPremises);\r\n      };\r\n      this.orIntroduction = function () {\r\n        this.showDisjoinField = true;\r\n      };\r\n      this.reiterate = function() {\r\n        var reiterated, currentScope, selected;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        reiterated = selected.map(function(premise, key) {\r\n                            return Premise.new({\r\n                                scopeLayer: currentScope.layer,\r\n                                scopeId: currentScope.id,\r\n                                value: premise.value\r\n                            });\r\n                        });\r\n        _.forEach(reiterated, function (premise) {\r\n          _entail.call(this, premise, selected);\r\n        }.bind(this));\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n      };\r\n      this.delete = function () {\r\n        var selected, scopeIds;\r\n        selected = _getSelectedPremises(this.premiseGraph.premises);\r\n        _.forEach(selected, function (premise) {\r\n          this.premiseGraph.removeNode(premise);\r\n        }.bind(this));\r\n        scopeIds = _.map(this.premiseGraph.premises, 'scopeId');\r\n        this.structure.reset(this.premiseGraph.premises);\r\n      };\r\n      this.biconditionalIntro = function () {\r\n        var selected, newPremises, secondPremise, currentScope;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length !== 2) {\r\n          return;\r\n        }\r\n        newPremises = fitchBicondition.introduction(selected, currentScope);\r\n        if (!newPremises) {\r\n          return;\r\n        }\r\n        _multipleEntialment.call(this, newPremises, selected);\r\n      }\r\n      this.biconditionalElim = function () {\r\n        var selected, newPremises, secondPremise, currentScope;\r\n        currentScope = this.structure.getCurrentScope();\r\n        selected = _getValidSelecedPremises(this.premiseGraph.premises, this.structure.scopes);\r\n        _uncheckPremises(this.premiseGraph.premises, this.selected);\r\n        if (selected.length !== 1) {\r\n          return;\r\n        }\r\n        newPremises = fitchBicondition.elimination(selected[0], currentScope);\r\n        if (!newPremises) {\r\n          return;\r\n        }\r\n        _multipleEntialment.call(this, newPremises, selected);\r\n      }\r\n\r\n      /*Local functions*/\r\n      function _init() {\r\n        this.marginLeft = 20; //pixels\r\n        this.premise = '';\r\n        this.premiseGraph = PremiseTree.new();\r\n        this.selected = [];\r\n        this.showDisjoinField = false;\r\n        this.structure = FitchStack.new();\r\n        this.valueToDisjoin = '';\r\n      }\r\n      function _entail(premise, parentPremises) {\r\n        this.structure.entail(premise);\r\n        _appendPremiseChild(this.premiseGraph, premise, parentPremises);\r\n      }\r\n\r\n      function _multipleEntialment(premises, parentPremises) {\r\n        _.forEach(premises, function (premise) {\r\n          _entail.call(this, premise, parentPremises);\r\n        }.bind(this));\r\n      }\r\n\r\n      function _getSelectedPremises(premises) {\r\n        return _.filter(premises, 'checked');\r\n      }\r\n\r\n      function _getValidSelecedPremises(premises, scopes) {\r\n        var scopeIds = _.map(scopes, 'id');\r\n        return _getSelectedPremises(premises)\r\n               .filter(function(premise) {\r\n                    return scopeIds.indexOf(premise.scopeId) !== -1;\r\n                });\r\n      }\r\n\r\n      function _uncheckPremises(premises, selected) {\r\n        selected.length = 0;\r\n        return _.map(premises, function(premise) {\r\n            premise.checked = false;\r\n            return premise;\r\n        });\r\n      }\r\n\r\n      function _groupOrPremises(premises) {\r\n        var disjunctions, implications;\r\n        disjunctions = _.filter(premises, function (premise) {\r\n          return premise.isOr(premise.digest());\r\n        });\r\n        if  (disjunctions.length !== 1) {\r\n          return null;\r\n        }\r\n        implications = _.filter(premises, function (premise) {\r\n          return premise.isImplication(premise.digest());\r\n        });\r\n        if  (implications.length !== premises.length - 1) {\r\n          return null;\r\n        }\r\n        return {\r\n          disjunctions: disjunctions,\r\n          implications: implications\r\n        };\r\n      }\r\n\r\n      function _appendPremiseChild(structrue, childPremise, parentPremises) {\r\n        _.forEach(parentPremises, function (premise) {\r\n          structrue.appendChildNode(premise, childPremise);\r\n        });\r\n      }\r\n\r\n    });\r\n","'use strict';\r\nangular\r\n  .module('logicToolsApp')\r\n  .controller('MainCtrl', function ($location) {\r\n        this.goToTruth = function() {\r\n            $location.path('/truth-tables');\r\n        };\r\n        this.goToFitch = function() {\r\n            $location.path('/fitch');\r\n        };\r\n  });\r\n","'use strict';\r\n\r\nangular.module('logicToolsApp')\r\n  .controller('MenuCtrl', function () {\r\n    \r\n  });\r\n","'use strict';\r\n\r\nangular\r\n  .module('logicToolsApp')\r\n  .controller('TruthTableCtrl', function (tableGenerator) {\r\n        this.premises = [];\r\n        this.selectedPremises = [];\r\n        this.premise = '';\r\n        this.truthTable = {};\r\n        this.build = function() {\r\n            if(this.premise) {\r\n                tableGenerator.generate(this.premise);\r\n                this.truthTable.header = getTableHeader(tableGenerator);\r\n                this.truthTable.rows = getTableRows(tableGenerator);\r\n            }\r\n        };\r\n        function readPremise(premise) {\r\n            return premise.trim().split(/\\s+/g);\r\n        }\r\n        function getTableHeader(table) {\r\n            return _.chain(table.value).keys().map(function(val, key) {\r\n                return (val in this.labels) ? this.labels[val] : val;\r\n            }.bind(table)).value();\r\n        }\r\n        function getTableRows(table) {\r\n            var rows, tableValue;\r\n            rows = [];\r\n            tableValue = table.value;\r\n            _.each(_.values(tableValue), function(col, keyc) {\r\n                _.each(col, function(val, keyr) {\r\n                    if (!rows[keyr]) {\r\n                      rows.push([]);\r\n                    }\r\n                    rows[keyr][keyc] = val;\r\n                });\r\n            });\r\n            return rows;\r\n        }\r\n  });\r\n","angular\r\n  .module('logicToolsApp')\r\n  .factory('FitchStack', function(Scope) {\r\n\r\n    var scopeLayer, universalScope;\r\n    scopeLayer = 0;\r\n    universalScope = Scope.new({\r\n      layer: scopeLayer\r\n    });\r\n\r\n    function FitchStack(props) {\r\n      scopeLayer = 0;\r\n      this.scopes = [universalScope];\r\n      this.scopeHistory = [universalScope];\r\n    }\r\n\r\n    FitchStack.prototype.closeScope = function() {\r\n      var removedScope, newCurrentScope;\r\n      removedScope = _.remove(this.scopes, 'isFocused');\r\n      newCurrentScope = this.scopes[this.scopes.length - 1];\r\n      if (!newCurrentScope) {\r\n        return removedScope[0];\r\n      }\r\n      newCurrentScope.focus();\r\n      newCurrentScope.layer = --scopeLayer;\r\n      return removedScope[0];\r\n    };\r\n\r\n    FitchStack.prototype.openScope = function(headAssumption) {\r\n      var scope = Scope.new({\r\n        head: headAssumption,\r\n        layer: ++scopeLayer\r\n      });\r\n\r\n      if (this.scopes.length) {\r\n        this.scopes = _.map(this.scopes, function(scope) {\r\n          scope.blur();\r\n          return scope;\r\n        });\r\n      }\r\n\r\n      this.scopes.push(scope);\r\n      this.scopeHistory.push(scope);\r\n    };\r\n\r\n    FitchStack.prototype.entail = function(assumption) {\r\n      var currentScope = this.getCurrentScope();\r\n      currentScope.append(assumption);\r\n    };\r\n\r\n    FitchStack.prototype.getCurrentScope = function() {\r\n      return _.filter(this.scopes, 'isFocused')[0];\r\n    };\r\n\r\n    FitchStack.prototype.reset = function (premises) {\r\n      var currentScope;\r\n      this.scopes.length = 0;\r\n      this.scopeHistory.length = 0;\r\n      this.scopes = _setScopesItems(_createScopes(premises), premises);\r\n      currentScope = _.find(this.scopes, {\r\n        id: _getLastItem(premises).scopeId\r\n      });\r\n      currentScope.focus();\r\n      scopeLayer = currentScope.layer;\r\n      this.scopeHistory = this.scopes;\r\n      this.scopes = _getActiveScopes(this.scopes, premises);\r\n    }\r\n\r\n    function _getLastItem(items) {\r\n      return items.slice(-1)[0];\r\n    }\r\n\r\n    function _createScopes(premises) {\r\n      var scopes = _.chain(premises)\r\n                    .map(function (premise) {\r\n                      return {\r\n                        layer: premise.scopeLayer,\r\n                        id: premise.scopeId\r\n                      };\r\n                    })\r\n                    .uniqBy('id')\r\n                    .map(function (scopeBase) {\r\n                      return Scope.new({\r\n                        layer: scopeBase.layer,\r\n                        id: scopeBase.id\r\n                      });\r\n                    })\r\n                    .value();\r\n      return _.find(scopes, {layer: 0}) \r\n                  ? scopes\r\n                  : [universalScope].concat(scopes);\r\n    }\r\n\r\n    function _premisesByScope(premises) {\r\n      return _.groupBy(premises, 'scopeId');\r\n    }\r\n\r\n    function _setScopesItems(scopes, premises) {\r\n      return _.chain(scopes)\r\n              .map(function (scope) {\r\n                scope.items = _.sortBy(_premisesByScope(premises)[scope.id], 'scopeId');\r\n                scope.blur();\r\n                return scope;\r\n              })\r\n              .value();\r\n    }\r\n\r\n    function _getActiveScopes(scopes, premises) {\r\n      var prevScopeLayer, prevScopePosition, activeIds, scopePosition;\r\n      activeIds = [universalScope.id];\r\n      prevScopeLayer = 0;\r\n      _.forEach(premises, function (premise) {\r\n        scopePosition = activeIds.indexOf(premise.scopeId);\r\n        if (prevScopeLayer <= premise.scopeLayer && scopePosition === -1) {\r\n          activeIds.push(premise.scopeId);\r\n        } else if (prevScopeLayer > premise.scopeLayer && scopePosition !== -1) {\r\n          activeIds.splice(prevScopePosition, 1);\r\n        }\r\n        prevScopeLayer = premise.scopeLayer;\r\n        prevScopePosition = scopePosition;\r\n      });\r\n      return _.filter(scopes, function (scope) {\r\n        return activeIds.indexOf(scope.id) !== -1;\r\n      });\r\n    }\r\n\r\n    return {\r\n      new: function(props) {\r\n        var fitchProps = props || {};\r\n        return new FitchStack(fitchProps);\r\n      }\r\n    }\r\n\r\n  });\r\n","angular\r\n  .module('logicToolsApp')\r\n  .factory('PremiseTree', function () {\r\n\r\n    function PremiseTree(props) {\r\n      this.premises = [];\r\n      this.proofTree = [];\r\n    }\r\n\r\n    PremiseTree.prototype.appendNode = function (premiseNode) {\r\n      this.proofTree.push([]);\r\n      this.premises.push(premiseNode);\r\n    }\r\n\r\n    PremiseTree.prototype.appendChildNode = function (parentPremise, childPremise) {\r\n      var parentIndex, childIndex;\r\n      parentIndex = this.premises.indexOf(parentPremise);\r\n      childIndex = this.premises.indexOf(childPremise);\r\n\r\n      this.proofTree[parentIndex].push(childPremise.id);\r\n\r\n      if (childIndex === -1) {\r\n        this.premises.push(childPremise);\r\n        this.proofTree.push([]);\r\n      }\r\n    }\r\n\r\n    PremiseTree.prototype.removeNode = function (premiseToRemove) {\r\n      var childrenIds, grandChildrenIds;\r\n      childrenIds = _getChildrenIds(this.proofTree, this.premises, premiseToRemove);\r\n      while (childrenIds.length) {\r\n        grandChildrenIds = _getGrandchildren(this.proofTree, this.premises, childrenIds);\r\n        this.proofTree = _cutTree(this.proofTree, this.premises, childrenIds);\r\n        this.premises = _cutPremises(this.premises, childrenIds);\r\n        childrenIds = grandChildrenIds;\r\n      }\r\n      this.proofTree = _removeTreeNode(this.proofTree, this.premises, premiseToRemove);\r\n      this.premises = _removePremise(this.premises, premiseToRemove);\r\n      return this.premises;\r\n    }\r\n\r\n    function _removePremise(premises, premiseToRemove) {\r\n      var filteredPremises = _.filter(premises, function (premise) {\r\n        return premise.id !== premiseToRemove.id;\r\n      });\r\n      return _mergePremiseScopes(filteredPremises, premiseToRemove);\r\n    }\r\n\r\n    function _removeChildNode(node, childNode) {\r\n      return _.filter(node, function (child) {\r\n        return child !== childNode;\r\n      });\r\n    }\r\n\r\n    function _removeInvalidChildren(node, premises) {\r\n      return _.filter(node, function (child) {\r\n        return !!_findPremise(premises, child);\r\n      });\r\n    }\r\n\r\n    function _removeTreeNode(proofTree, premises, premiseToRemove) {\r\n      var premiseIndex = _getPremiseNodeIndex(premises, premiseToRemove);\r\n      return _.chain(proofTree)\r\n              .filter(function (node, indexNode) {\r\n                return indexNode !== premiseIndex;\r\n              })\r\n              .map(function (node) {\r\n                var newNode = _removeChildNode(node, premiseToRemove.id);\r\n                return _removeInvalidChildren(newNode, premises);\r\n              })\r\n              .value();\r\n    }\r\n\r\n    function _findPremise(premises, id) {\r\n      return _.find(premises, {id: id});\r\n    }\r\n\r\n    function _getChildrenIds(proofTree, premises, premise) {\r\n      var index = _getPremiseNodeIndex(premises, premise);\r\n      return proofTree[index];\r\n    }\r\n\r\n    function _getPremiseNodeIndex(premises, premise) {\r\n      return _.chain(premises)\r\n              .map('id')\r\n              .indexOf(premise.id)\r\n              .value();\r\n    }\r\n\r\n    function _cutTree(proofTree, premises, ids) {\r\n      return _.filter(proofTree, function (node, indexNode) {\r\n        return ids.indexOf(premises[indexNode].id) === -1;\r\n      });\r\n    }\r\n\r\n    function _cutPremises(premises, ids) {\r\n      return  _.filter(premises, function (premise) {\r\n        return ids.indexOf(premise.id) === -1;\r\n      });\r\n    }\r\n\r\n    function _getGrandchildren(proofTree, premises, childrenIds) {\r\n      return _.chain(childrenIds)\r\n              .map(function (id) {\r\n                var premise = _findPremise(premises, id) || {};\r\n                return _getChildrenIds(proofTree, premises, premise);\r\n               })\r\n              .flattenDeep()\r\n              .filter(function (id) {\r\n                return !!id;\r\n              })\r\n              .value();\r\n    }\r\n\r\n    function _mergePremiseScopes(premises, premiseToRemove) {\r\n      var prevScopeId, prevScopeLayer, layerIncrement;\r\n      layerIncrement = 0;\r\n      return _.map(premises, function (premise) {\r\n        if (prevScopeLayer === premise.scopeLayer && prevScopeId !== premise.scopeId) {\r\n          layerIncrement++;\r\n        }\r\n        prevScopeLayer = premise.scopeLayer;\r\n        prevScopeId = premise.scopeId;\r\n        premise.scopeLayer += layerIncrement;\r\n        return premise;\r\n      });\r\n    }\r\n\r\n    return {\r\n      new: function (props) {\r\n        return new PremiseTree(props);\r\n      }\r\n    };\r\n\r\n  });\r\n","angular\r\n  .module('logicToolsApp')\r\n  .factory('Scope', function() {\r\n\r\n    var id = 0;\r\n    function Scope(props) {\r\n      this.id = props.id || ++id;\r\n      this.layer = props.layer;\r\n      this.isFocused = true;\r\n      this.items = [];\r\n\r\n      if (props.head) {\r\n        this.items.push(props.head);\r\n      }\r\n    }\r\n\r\n    Scope.prototype.append = function(item) {\r\n      this.items.push(item);\r\n    }\r\n\r\n    Scope.prototype.blur = function() {\r\n      this.isFocused = false;\r\n    }\r\n\r\n    Scope.prototype.focus = function() {\r\n      this.isFocused = true;\r\n    }\r\n\r\n    Scope.prototype.remove = function(item) {\r\n      var index = item.indexOf(item);\r\n      return this.items.splice(index, 1);\r\n    }\r\n\r\n    Object.defineProperty(Scope.prototype, 'head', {\r\n      get: function() {\r\n        return this.items[0];\r\n      }\r\n    });\r\n\r\n    Object.defineProperty(Scope.prototype, 'last', {\r\n      get: function() {\r\n        return this.items[this.items.length - 1];\r\n      }\r\n    });\r\n\r\n    Object.defineProperty(Scope.prototype, 'size', {\r\n      get: function() {\r\n        return this.items.length;\r\n      }\r\n    });\r\n\r\n    return {\r\n      new: function(props) {\r\n        var scopeProps = props || {};\r\n        return new Scope(scopeProps);\r\n      }\r\n    }\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular\r\n  .module('logicToolsApp')\r\n  .factory('formula', function() {\r\n\r\n    function isThen(premise) {\r\n      return /[=][>]/g.exec(premise);\r\n    }\r\n    function isAnd(premise) {\r\n      return /[&]/g.exec(premise);\r\n    }\r\n    function isOr(premise) {\r\n      return /[|]/g.exec(premise);\r\n    }\r\n    function isBicon(premise) {\r\n      return /[<][=][>]/g.exec(premise);\r\n    }\r\n\r\n    return {\r\n      /*Truth table methods*/\r\n      resultFn: function(premise) {\r\n        var getResult;\r\n        if (isBicon(premise)) {\r\n            getResult = function(a, b) {\r\n                return (!a || b) && (!b || a);\r\n            }\r\n        } else if (isThen(premise)) {\r\n            getResult = function(a, b) {\r\n                return !a || b;\r\n            }\r\n        } else if (isAnd(premise)) {\r\n            getResult = function(a, b) {\r\n                return a && b;\r\n            }\r\n        } else if (isOr(premise)) {\r\n            getResult = function(a, b) {\r\n                return a || b;\r\n            }\r\n        }\r\n        return getResult;\r\n      }\r\n    }\r\n  });\r\n","angular\r\n  .module('logicToolsApp')\r\n  .service('syntaxChecker', function () {\r\n    this.validate = function (premise) {\r\n      if (_emptyPremise(premise)) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    function _emptyPremise(premise) {\r\n      return !premise.value;\r\n    }\r\n    \r\n  });\r\n","angular\r\n  .module('logicToolsApp')\r\n  .service('fitchBicondition', function (Premise) {\r\n    this.introduction = function (premises, scope) {\r\n      if (!_validatePremises(premises[0], premises[1])) {\r\n        return null;\r\n      }\r\n      if (!_validateImplications(premises[0], premises[1])) {\r\n        return null;\r\n      }\r\n      return _getBiconditions(premises, scope);\r\n    };\r\n\r\n    this.elimination = function (premise, scope) {\r\n      var digested = premise.digest();\r\n      if (!premise.isBicon(digested)) {\r\n        return null;\r\n      }\r\n\r\n      return _getImplications(premise, digested, scope);\r\n    }\r\n\r\n    function _validatePremises(firstPremise, secondPremise) {\r\n      var firstValue, secondValue;\r\n      firstValue = firstPremise.digest();\r\n      secondValue = secondPremise.digest();\r\n      return firstPremise.isImplication(firstValue) && secondPremise.isImplication(secondValue);\r\n    }\r\n    function _validateImplications(firstPremise, secondPremise) {\r\n      var firstValue, secondValue, firstConclusion, firstAssumption,\r\n          secondConclusion, secondAssumption;\r\n      firstValue = firstPremise.digest();\r\n      secondValue = secondPremise.digest();\r\n      firstConclusion = firstPremise.getExpandedConclusion(firstValue);\r\n      firstAssumption = firstPremise.getExpandedAssumption(firstValue);\r\n      secondConclusion = secondPremise.getExpandedConclusion(secondValue);\r\n      secondAssumption = secondPremise.getExpandedAssumption(secondValue);\r\n      return firstConclusion === secondAssumption && secondConclusion === firstAssumption;\r\n    }\r\n    function _getImplications(premise, digested, scope) {\r\n      var atomics, index;\r\n      atomics = digested.split(/[<][=][>]/g);\r\n      index = atomics.length;\r\n      return _.map(atomics, function (atomicPremise) {\r\n        index--;\r\n        return Premise.new({\r\n          scopeLayer: scope.layer,\r\n          scopeId: scope.id,\r\n          value: premise.expand(atomicPremise) + '=>' + premise.expand(atomics[index])\r\n        });\r\n      });\r\n    }\r\n    function _getBiconditions(premises, scope) {\r\n      return _.map(premises, function (premise) {\r\n        var value = premise.digest()\r\n        return Premise.new({\r\n          scopeLayer: scope.layer,\r\n          scopeId: scope.id,\r\n          value: premise.getExpandedConclusion(value) + '<=>' + premise.getExpandedAssumption(value)\r\n        })\r\n      });\r\n    }\r\n  });\r\n","angular\r\n  .module('logicToolsApp')\r\n  .service('fitchConjunction', function (Premise) {\r\n    this.introduction = function (premises, scope) {\r\n      var selectedValues = _.map(premises, function (premise) {\r\n          return (premise.isCompound())\r\n                    ? '(' + premise.value + ')'\r\n                    : premise.value;\r\n      })\r\n      return _getConjuctions(selectedValues, scope);\r\n    }\r\n    this.elimination = function (premise, scope) {\r\n      var digestedPremise = premise.digest();\r\n      return _.chain(digestedPremise)\r\n              .split(/\\&+/)\r\n              .map(function (simplePremise) {\r\n                var expanded = premise.expand(simplePremise)\r\n                return Premise.new({\r\n                  scopeLayer: scope.layer,\r\n                  scopeId: scope.id,\r\n                  value: premise.unwrap(expanded)\r\n                });\r\n              })\r\n              .value();\r\n    }\r\n\r\n    function _getConjuctions(premisesValue, scope) {\r\n      return _.chain(premisesValue)\r\n              .map(function (premiseValue) {\r\n                return _getPosibleJoins(premiseValue, premisesValue, scope);\r\n              })\r\n              .flattenDeep()\r\n              .value();\r\n    }\r\n\r\n    function _getPosibleJoins(value, premisesValue, scope) {\r\n      return _.map(premisesValue, function (premiseValue) {\r\n        return Premise.new({\r\n          scopeLayer: scope.layer,\r\n          scopeId: scope.id,\r\n          value: value + '&' + premiseValue\r\n        });\r\n      });\r\n    }\r\n  });\r\n","'use strict';\r\n\r\nangular\r\n  .module('logicToolsApp')\r\n  .service('fitchDisjunction', function (Premise) {\r\n\r\n    this.elimination = function (premises, scope) {\r\n      var uniqueConclusions, assumptions, disjunction;\r\n      assumptions = _getAssumptions(premises.implications);\r\n      uniqueConclusions = _getUniqueConclusions(premises.implications);\r\n\r\n      if(uniqueConclusions.length !== 1) {\r\n        return null;\r\n      }\r\n\r\n      if(!_isValidOperation(assumptions, premises.disjunctions[0])) {\r\n        return null;\r\n      }\r\n\r\n      return Premise.new({\r\n        scopeLayer: scope.layer,\r\n        scopeId: scope.id,\r\n        value: uniqueConclusions[0]\r\n      });\r\n\r\n    }\r\n\r\n    this.introduction = function (value, selected, scope) {\r\n      var selectedValues = _.map(selected, function (premise) {\r\n          return (premise.isCompound())\r\n                    ? '(' + premise.value + ')'\r\n                    : premise.value;\r\n      });\r\n\r\n      return _getDisjunctions(value, selectedValues, scope)\r\n    }\r\n\r\n    function _getUniqueConclusions(implications) {\r\n      return _.chain(implications)\r\n              .map(function (premise) {\r\n                  return premise.expand(premise.getConclusion(premise.digest()));\r\n              })\r\n              .uniq()\r\n              .value();\r\n    }\r\n\r\n    function _getAssumptions(implications) {\r\n      return _.map(implications, function (premise) {\r\n                   return premise.expand(premise.getAssumption(premise.digest()));\r\n              });\r\n    }\r\n\r\n    function _getDisjunctions(value, premisesValue, scope) {\r\n      return _.chain(premisesValue)\r\n              .map(function (premiseValue) {\r\n                return _getPosibleJoins([value, premiseValue], scope);\r\n              })\r\n              .flattenDeep()\r\n              .value();\r\n    }\r\n\r\n    function _getPosibleJoins(premisesValue, scope) {\r\n      var index = premisesValue.length;\r\n      return _.map(premisesValue, function (premiseValue) {\r\n        index--;\r\n        return Premise.new({\r\n          scopeLayer: scope.layer,\r\n          scopeId: scope.id,\r\n          value: premiseValue + '|' + premisesValue[index]\r\n        });\r\n      });\r\n    }\r\n\r\n    function _isValidOperation(premises, disjunction) {\r\n      var structure, assumptions;\r\n      structure = disjunction.digest();\r\n      assumptions = premises.slice();\r\n\r\n      return _.filter(structure.split(/\\|+/), function(label) {\r\n          return assumptions.indexOf(disjunction.expand(label)) !== -1\r\n      }).length === premises.length;\r\n    }\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular\r\n  .module('logicToolsApp')\r\n  .service('fitchImplication', function (Premise) {\r\n\r\n    this.introduction = function(scope, lastScope) {\r\n      var head, last, digestedHead, digestedLast, assumption, conclusion;\r\n      head = lastScope.head;\r\n      last = lastScope.last;\r\n      digestedHead = head.digest();\r\n      digestedLast = last.digest();\r\n\r\n      assumption = (head.isCompound(head.value))\r\n                      ? '(' + head.value + ')'\r\n                      : head.value;\r\n\r\n      conclusion = (last.isCompound(last.value))\r\n                      ? '(' + last.value + ')'\r\n                      : last.value;\r\n      \r\n      if (head.hasNegation(digestedHead) && digestedHead !== head.value) {\r\n          assumption = head.value;\r\n      }\r\n      if (last.hasNegation(digestedLast) && digestedLast !== last.value) {\r\n          conclusion = last.value;\r\n      }\r\n\r\n      return Premise.new({\r\n        scopeLayer: scope.layer,\r\n        scopeId: scope.id,\r\n        value: assumption + '=>' + conclusion\r\n      });\r\n    };\r\n\r\n    this.elimination = function(premiseOne, premiseTwo, scope) {\r\n      var newPremise = eliminate(premiseTwo, premiseOne, scope) || eliminate(premiseOne, premiseTwo, scope);\r\n      if (!newPremise) {\r\n        return null;\r\n      }\r\n      newPremise.scopeLayer = scope.layer;\r\n      newPremise.scopeId = scope.id;\r\n      return newPremise;\r\n    };\r\n\r\n    function eliminate(premiseOne, premiseTwo, scope) {\r\n      var assumption, conclusion, structure, assumptionNegated;\r\n      structure = premiseOne.digest();\r\n      assumption = premiseOne.getAssumption(structure);\r\n      assumptionNegated = premiseOne.hasNegation(assumption);\r\n      assumption = premiseOne.expand(assumption);\r\n      assumption = (assumptionNegated)\r\n      ? assumption\r\n      : premiseOne.unwrap(assumption);\r\n\r\n  \t\tif (assumption === premiseTwo.value) {\r\n        conclusion = premiseOne.getConclusion(structure);\r\n  \t\t\treturn Premise.new({\r\n  \t\t\t\tscopeLayer : scope.layer,\r\n  \t\t\t\tscopeId : scope.id,\r\n  \t\t\t\tvalue: premiseOne.expand(conclusion)\r\n  \t\t\t});\r\n  \t\t}\r\n    \treturn null;\r\n    }\r\n  });\r\n","'use strict';\r\n\r\nangular\r\n  .module('logicToolsApp')\r\n  .service('fitchNegation', function (Premise) {\r\n\r\n    this.introduction = function(premiseOne, premiseTwo, scope) {\r\n      var newValue;\r\n\r\n    \tif (!_validImplications(premiseOne, premiseTwo)) {\r\n  \t\t\treturn null;\r\n  \t\t}\r\n  \t\tif (!_validPremises(premiseOne, premiseTwo)) {\r\n  \t\t\treturn null;\r\n  \t\t}\r\n  \t\tif (!_validNegations(premiseOne, premiseTwo)) {\r\n  \t\t\treturn null;\r\n  \t\t}\r\n  \t\tif (!_validConclusions(premiseOne, premiseTwo)) {\r\n  \t\t\treturn null;\r\n  \t\t}\r\n\r\n      newValue = _getAssumption(premiseOne);\r\n\r\n      return Premise.new({\r\n        scopeLayer: scope.layer,\r\n        scopeId: scope.id,\r\n  \t    value: '~' + newValue\r\n      });\r\n    };\r\n\r\n    this.elimination = function(premise, scope) {\r\n      var structure, newValue, negations;\r\n      structure = premise.digest();\r\n      negations = premise.value.match(/^\\~+/)[0];\r\n\r\n      if (negations.length <= 1) {\r\n          return;\r\n      }\r\n\r\n      newValue = negations.slice(2) + premise.removeNegation(structure);\r\n      newValue = (!premise.hasNegation(newValue))\r\n      ? premise.unwrap(premise.expand(newValue))\r\n      : premise.expand(newValue);\r\n\r\n  \t\treturn Premise.new({\r\n        scopeLayer: scope.layer,\r\n        scopeId: scope.id,\r\n        value: newValue\r\n      });\r\n  \t};\r\n\r\n  \tfunction _validImplications(premiseOne, premiseTwo) {\r\n  \t\treturn premiseOne.isImplication() && premiseTwo.isImplication();\r\n  \t}\r\n\r\n  \tfunction _validPremises(premiseOne, premiseTwo) {\r\n  \t\treturn _getAssumption(premiseOne) === _getAssumption(premiseTwo);\r\n  \t}\r\n\r\n  \tfunction _validNegations(premiseOne, premiseTwo) {\r\n  \t\treturn _validNegation(premiseOne, premiseTwo) || _validNegation(premiseTwo, premiseOne);\r\n  \t}\r\n\r\n  \tfunction _validConclusions(premiseOne, premiseTwo) {\r\n  \t\treturn _validConclusion(premiseOne, premiseTwo) || _validConclusion(premiseTwo, premiseOne);\r\n  \t}\r\n\r\n  \tfunction _validConclusion(premiseOne, premiseTwo) {\r\n  \t\treturn _getPureConclusion(premiseOne) === _getConclusion(premiseTwo);\r\n  \t}\r\n\r\n  \tfunction _validNegation(premiseOne, premiseTwo) {\r\n      var conclusionOne, conclusionTwo;\r\n      conclusionOne = _getRawConclusion(premiseOne);\r\n      conclusionTwo = _getRawConclusion(premiseTwo);\r\n  \t\treturn premiseOne.hasNegation(conclusionOne) && !premiseOne.hasNegation(conclusionTwo);\r\n  \t}\r\n\r\n    function _removeNegation(premise) {\r\n      return premise.replace(/\\~+/g,'');\r\n    }\r\n\r\n    function _getAssumption(premise) {\r\n      var structure, assumption;\r\n      structure = premise.digest();\r\n      assumption = premise.getAssumption(structure);\r\n      return premise.expand(assumption);\r\n    }\r\n\r\n    function _getConclusion(premise) {\r\n      var structure, conclusion, expanded;\r\n      structure = premise.digest();\r\n      conclusion = premise.getConclusion(structure);\r\n      expanded = premise.expand(_removeNegation(conclusion));\r\n      return (premise.hasNegation(conclusion))\r\n      ? '~' + expanded\r\n      : expanded;\r\n    }\r\n\r\n    function _getPureConclusion(premise) {\r\n      var structure, conclusion, expanded;\r\n      structure = premise.digest();\r\n      conclusion = premise.getConclusion(structure);\r\n      return premise.expand(_removeNegation(conclusion));\r\n    }\r\n\r\n    function _getRawConclusion(premise, structure) {\r\n      var structure, conclusion;\r\n      structure = premise.digest();\r\n      conclusion = premise.getConclusion(structure);\r\n      return conclusion;\r\n    }\r\n\r\n});\r\n","angular\r\n  .module('logicToolsApp')\r\n  .factory('Premise', function() {\r\n\r\n    var NEGATION_REGEX, IMPLICATION_REGEX, id;\r\n    NEGATION_REGEX = /^\\~+/;\r\n    IMPLICATION_REGEX = /[=][>]/g;\r\n    id = 0;\r\n\r\n  \tfunction Premise(props) {\r\n      this.labels = {};\r\n      this.id = ++id;\r\n      this.scopeLayer = props.scopeLayer;\r\n      this.scopeId = props.scopeId;\r\n      this.value = _removeSpaces(props.value);\r\n  \t}\r\n\r\n    Premise.prototype.digest = function(callback) {\r\n      var premises, copyPremise, label, labels, value;\r\n      value = this.value;\r\n      premises = [];\r\n      labels = {};\r\n      label = 0;\r\n\r\n      while(premises) {\r\n        premises = _breakPremise(value);\r\n        _.each(_extractPremises(value), function(premise) {\r\n          copyPremise = premise.slice();\r\n          labels[++label] = _createLabels(labels, copyPremise);\r\n          value = _reducePremise(value, _unwrap(premise), label);\r\n          if (callback) {\r\n              callback(premise, value, label);\r\n          }\r\n        });\r\n      }\r\n      this.labels = _.assign({}, labels);\r\n      return value;\r\n    }\r\n\r\n    Premise.prototype.isImplication = function(structrue) {\r\n  \t  var base = structrue || this.value;\r\n      return !!base.match(IMPLICATION_REGEX);\r\n    };\r\n    Premise.prototype.isAnd = function (structrue) {\r\n      var base = structrue || this.value;\r\n      return /[&]/g.exec(base);\r\n    };\r\n    Premise.prototype.isOr = function (structrue) {\r\n      var base = structrue || this.value;\r\n      return /[|]/g.exec(base);\r\n    };\r\n    Premise.prototype.isBicon = function (structrue) {\r\n      var base = structrue || this.value;\r\n      return /[<][=][>]/g.exec(base);\r\n    };\r\n    Premise.prototype.expand = function(premiseLabel) {\r\n      var premise, indexPremise, labels, symbol;\r\n      indexPremise = premiseLabel.replace(NEGATION_REGEX, '');\r\n      labels = this.labels;\r\n      premise = labels[indexPremise] || this.removeNegation(premiseLabel);\r\n      symbol = (this.hasNegation(premiseLabel))\r\n      ? premiseLabel.match(NEGATION_REGEX)[0]\r\n      : '';\r\n      return  symbol + _expandPremise(labels, premise);\r\n    };\r\n    Premise.prototype.getAssumption = function(structrue) {\r\n      var base, splited\r\n      base = structrue || this.value;\r\n      splited = _splitImplication(base);\r\n      return (splited) ? splited[0] : undefined;\r\n    };\r\n    Premise.prototype.getConclusion = function(structrue) {\r\n      var base, splited\r\n      base = structrue || this.value;\r\n      splited = _splitImplication(base);\r\n      return (splited) ? splited[1] : undefined;\r\n    };\r\n    Premise.prototype.getExpandedAssumption = function(structrue) {\r\n      var base, splited\r\n      base = structrue || this.value;\r\n      splited = _splitImplication(base);\r\n      return (splited) ? this.expand(splited[0]) : undefined;\r\n    };\r\n    Premise.prototype.getExpandedConclusion = function(structrue) {\r\n      var base, splited\r\n      base = structrue || this.value;\r\n      splited = _splitImplication(base);\r\n      return (splited) ? this.expand(splited[1]) : undefined;\r\n    };\r\n    Premise.prototype.getPrimitives = function(structrue) {\r\n      var base = structrue || this.value;\r\n      return base.match(/\\w+/g);\r\n    }\r\n    Premise.prototype.removeNegation = function(structrue) {\r\n      var base = structrue || this.value;\r\n      return base.replace(NEGATION_REGEX, '');\r\n    }\r\n    Premise.prototype.hasNegation = function(structrue) {\r\n      var base = structrue || this.value;\r\n      return !!base.match(NEGATION_REGEX);\r\n    }\r\n    Premise.prototype.isCompound = function(structrue) {\r\n      var base = structrue || this.value;\r\n      return !!base.match(/[<=>|&]+/);\r\n    }\r\n    Premise.prototype.unwrap = function (value) {\r\n      return _unwrap(value || this.value);\r\n    };\r\n\r\n    function _breakPremise(value) {\r\n      return value.match(/[(]{1}[\\w~<=>|&]+(?=[)]{1})[)]{1}/g);\r\n    }\r\n\r\n    function _createLabels (labels, premise) {\r\n      var createdLabels;\r\n      createdLabels = _.keys(labels);\r\n      return Array.prototype.map.call(premise, function(val, k) {\r\n          return (createdLabels.indexOf(val) !== -1) ? labels[val] : val;\r\n      }).join('');\r\n    }\r\n\r\n    function _extractPremises(premise) {\r\n      return (_breakPremise(premise)) ? _breakPremise(premise) : [premise];\r\n    }\r\n\r\n    function _reducePremise(premise, subPremise, label) {\r\n      var matchExpr;\r\n      subPremise = subPremise.replace(/[|]/g, '[|]'); //This is special for the 'or' character.\r\n      matchExpr = new RegExp('[(]' + subPremise + '[)]', 'g');\r\n      return premise.replace(matchExpr, label);\r\n    }\r\n\r\n    function _expandPremise(labels, value) {\r\n      var premiseValue, labelsKeys, symbol;\r\n      premiseValue = value.slice();\r\n      labelsKeys = _.keys(labels);\r\n      return _.map(labelsKeys, function(label) {\r\n                premiseValue = premiseValue.replace(label, labels[label]);\r\n                return premiseValue;\r\n            }).slice(-1)[0];\r\n    }\r\n\r\n    function _splitImplication(value) {\r\n        return value.split(IMPLICATION_REGEX);\r\n    }\r\n\r\n    function _unwrap(value) {\r\n      var unwraped;\r\n      if (!value) {\r\n        return undefined;\r\n      }\r\n      unwraped = value.match(/[(]{1}([\\w\\W]+)[)]{1}/);\r\n      return (unwraped) ? unwraped[1] : value;\r\n    }\r\n\r\n    function _removeSpaces(value) {\r\n      return value.replace(/\\s+/g,'');\r\n    }\r\n\r\n    return {\r\n      new: function(props) {\r\n        return new Premise(props);\r\n      }\r\n    }\r\n\r\n  });\r\n","'use strict';\r\n\r\nangular\r\n  .module('logicToolsApp')\r\n  .service('tableGenerator', function(Premise, Table) {\r\n\r\n    var basePremise, table;\r\n    this.generate = function(premise) {\r\n      var premises, atomicPremises;\r\n      premises = [];\r\n      this.premise = premise;\r\n      basePremise = Premise.new({\r\n          value: premise\r\n      });\r\n      table = Table.new();\r\n      reset.call(this);\r\n      atomicPremises = _getAtomicPremises(premise);\r\n      this.value = _buildAtomicColumn(atomicPremises);\r\n      this.value = _.assign({}, this.value, _buildCompoundColumn(this.value));\r\n      this.labels = basePremise.labels;\r\n    };\r\n\r\n    function reset() {\r\n      this.value = {};\r\n      this.labels = {};\r\n    }\r\n\r\n    reset.call(this);\r\n\r\n    function _getAtomicPremises(premise) {\r\n      return _.uniq(premise.match(/[^~<=>()&|\\s]/g));\r\n    }\r\n    function _buildAtomicValues(value, key) {\r\n      var columns, column, rows;\r\n      columns = _.keys(value);\r\n      rows = Math.pow(2, columns.length);\r\n      column = 0;\r\n      return _.mapValues(value, function (value, key) {\r\n        return table.getAtomicValue(++column, rows);\r\n      });\r\n    }\r\n    function _buildAtomicColumn(atomicPremises) {\r\n      var initialPremises, premisesValues;\r\n      initialPremises = {};\r\n      _.forEach(atomicPremises, function (premise, key) {\r\n          initialPremises[premise] = [];\r\n          premisesValues = _buildAtomicValues(initialPremises, key);\r\n      });\r\n      return premisesValues;\r\n    }\r\n    function _buildCompoundColumn(tableValue) {\r\n      var values;\r\n      values = _.assign({}, tableValue);\r\n      basePremise.digest(function(premise, value, label) {\r\n          values[label] = table.getCompoundValue(premise, label, values);\r\n      });\r\n      return values;\r\n    }\r\n  });\r\n","angular\r\n  .module('logicToolsApp')\r\n  .factory('Table', function(formula) {\r\n\r\n    function Table () {}\r\n\r\n    Table.prototype.getCompoundValue = function(premise, key, tableValue) {\r\n      var ca, cb, c, a, b, getFormula, atomics, values;\r\n      getFormula = formula.resultFn(premise);\r\n      atomics = premise.match(/\\w+|[~]+\\w|\\d+|[~]+\\d/g);\r\n      values = [];\r\n      ca = _negateColumn(tableValue, atomics[0]);\r\n      cb = _negateColumn(tableValue, atomics[1]);\r\n      c = 0;\r\n      while (ca.length > c) {\r\n          a = ca[c];\r\n          b = cb[c];\r\n          values.push(Number(getFormula(a, b)));\r\n          c++;\r\n      }\r\n      return values;\r\n    }\r\n\r\n    Table.prototype.getAtomicValue = function(nCol, nRows) {\r\n      var values, value, row, nchange, sumup;\r\n      values = [];\r\n      value = 0;\r\n      row = 1;\r\n      sumup = 1;\r\n      nchange = Math.pow(2, nCol);\r\n      while (row <= nRows) {\r\n          if (((1 / nchange) * nRows) * sumup < row) {\r\n              value = 1 - value;\r\n              sumup++;\r\n          }\r\n          values.push(value);\r\n          row++;\r\n      }\r\n      return values;\r\n    }\r\n\r\n    function _negateColumn(value, premise) {\r\n      /*Negate if negation exists*/\r\n      var negation, result, atomic, operator;\r\n      negation = premise.match(/[~]/g);\r\n      atomic = premise.match(/\\w+/g);\r\n      if (negation) {\r\n          result = _.map(value[atomic[0]], function(val, key) {\r\n              operator = negation.join('').replace(/[~]/g, '!');\r\n              return Number(eval(operator + val));\r\n          });\r\n      } else {\r\n          result = value[atomic[0]];\r\n      }\r\n      return result;\r\n    }\r\n\r\n\t\treturn {\r\n\t\t\tnew: function() {\r\n\t\t\t\treturn new Table();\r\n\t\t\t}\r\n\t\t}\r\n\r\n  });\r\n"],"sourceRoot":"/source/"}